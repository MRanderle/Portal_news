import subprocess
import whisper
import numpy as np
import time
from googletrans import Translator
import asyncio
import re
import os
import shutil
import tempfile
from threading import Lock, Thread, RLock
import warnings
import json
import vlc
import threading
from faster_whisper import WhisperModel

try:
    import msvcrt  
    WINDOWS_LOCK_AVAILABLE = True
except ImportError:
    WINDOWS_LOCK_AVAILABLE = False

try:
    import fcntl  
    UNIX_LOCK_AVAILABLE = True
except ImportError:
    UNIX_LOCK_AVAILABLE = False

warnings.filterwarnings("ignore", message=".*weights_only=False.*")

def bloquear_arquivo(arquivo_handle, tipo_bloqueio='write'):
    """Implementa file locking multiplataforma"""
    try:
        if WINDOWS_LOCK_AVAILABLE:
            # Windows
            if tipo_bloqueio == 'write':
                msvcrt.locking(arquivo_handle.fileno(), msvcrt.LK_NBLCK, 1)
            else:
                msvcrt.locking(arquivo_handle.fileno(), msvcrt.LK_NBLCK, 1)
        elif UNIX_LOCK_AVAILABLE:
            # Unix/Linux
            if tipo_bloqueio == 'write':
                fcntl.flock(arquivo_handle.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
            else:
                fcntl.flock(arquivo_handle.fileno(), fcntl.LOCK_SH | fcntl.LOCK_NB)
        return True
    except (IOError, OSError):
        return False

def desbloquear_arquivo(arquivo_handle):
    """Remove file lock"""
    try:
        if WINDOWS_LOCK_AVAILABLE:
            msvcrt.locking(arquivo_handle.fileno(), msvcrt.LK_UNLCK, 1)
        elif UNIX_LOCK_AVAILABLE:
            fcntl.flock(arquivo_handle.fileno(), fcntl.LOCK_UN)
        return True
    except (IOError, OSError):
        return False

class TradutorLegendas:
    def __init__(self):
        self.ultimo_texto_legenda = None

        self.trava_legenda = RLock()  
        self.trava_arquivo_temp = Lock()  
        self.trava_processamento = Lock() 

        self.tamanho_modelo = "medium"
        self.entrada_rtmp = "rtmp://177.69.218.137:15140/stream/ypetv25"
        self.saida_rtmp = "rtmp://177.69.218.137:15140/stream/ypetv2"

        # ESTRAT√âGIA REVOLUCION√ÅRIA: SISTEMA DE DUPLO ARQUIVO
        # Arquivo 1: FFmpeg sempre l√™ (NUNCA modificado durante leitura)
        # Arquivo 2: Escrevemos aqui, depois copiamos para Arquivo 1
        diretorio_atual = os.path.abspath(".")
        
        self.caminho_legenda_ffmpeg = os.path.join(diretorio_atual, "legenda_for_ffmpeg.txt")      # Arquivo que FFmpeg l√™
        self.caminho_legenda_write = os.path.join(diretorio_atual, "legenda_write_buffer.txt")   # Arquivo que escrevemos
        
        # Para compatibilidade com c√≥digo existente
        self.caminho_legenda_temp = self.caminho_legenda_ffmpeg
        
        # Arquivos de backup
        self.arquivos_backup = [
            os.path.join(diretorio_atual, "legenda_backup1.txt"),
            os.path.join(diretorio_atual, "legenda_backup2.txt"),
            os.path.join(diretorio_atual, "legenda_backup3.txt"),
        ]
        
        # Verificar se temos permiss√£o de escrita no diret√≥rio atual
        try:
            arquivo_teste = os.path.join(diretorio_atual, "teste_permissao.tmp")
            with open(arquivo_teste, "w") as f:
                f.write("teste")
            os.remove(arquivo_teste)
            self.registrar_mensagem(f"‚úÖ Permiss√£o de escrita OK em: {diretorio_atual}")
        except Exception as e:
            self.registrar_mensagem(f"‚ùå ERRO: Sem permiss√£o de escrita em {diretorio_atual}: {e}")
            # Fallback para pasta do usu√°rio
            diretorio_usuario = os.path.expanduser("~")
            self.caminho_legenda_ffmpeg = os.path.join(diretorio_usuario, "legenda_for_ffmpeg.txt")
            self.caminho_legenda_write = os.path.join(diretorio_usuario, "legenda_write_buffer.txt")
            self.caminho_legenda_temp = self.caminho_legenda_ffmpeg
            self.arquivos_backup = [
                os.path.join(diretorio_usuario, "legenda_backup1.txt"),
                os.path.join(diretorio_usuario, "legenda_backup2.txt"),
                os.path.join(diretorio_usuario, "legenda_backup3.txt"),
            ]
            self.registrar_mensagem(f"üîÑ Usando diret√≥rio do usu√°rio: {diretorio_usuario}")
        
        # Sistema de verifica√ß√£o ULTRA-AGRESSIVO
        self.ultimo_update = time.time()
        self.contador_updates = 0
        self.falhas_consecutivas = 0
        self.arquivo_sempre_existe = True
        
        # NOVO: Sistema de sincroniza√ß√£o entre arquivos
        self.ultima_sincronizacao = 0
        self.intervalo_sincronizacao = 0.25  # Sincronizar a cada 250ms (muito mais agressivo)
        
        self.atraso_minimo = 1.0
        self.atraso_maximo = 0.0
        self.em_execucao = False
        self.atraso_video = 2.7
        self.atraso_legenda = -1.5                                 

        self.idioma_whisper = "Ingl√™s"
        self.traduzir_para_idioma = "Portugu√™s"

        self.idiomas_whisper = {
            "Auto detectar": None,
            "Ingl√™s": "en",
            "Portugu√™s": "pt",
            "Espanhol": "es",
            "Franc√™s": "fr",
            "Alem√£o": "de",
            "Italiano": "it",
            "Japon√™s": "ja",
            "Chin√™s": "zh",
            "Russo": "ru",
            "√Årabe": "ar"
        }

        self.idiomas_traducao = {
            "Portugu√™s": "pt",
            "Ingl√™s": "en",
            "Espanhol": "es",
            "Franc√™s": "fr",
            "Alem√£o": "de",
            "Italiano": "it",
            "Japon√™s": "ja",
            "Russo": "ru"
        }

        self.atraso_atual = 0.0
        self.tempo_processamento_anterior = 1.0
        self.ultima_transcricao = ""
        self.ultima_traducao = ""

        self.modelo = None
        self.tradutor = Translator()
        self.processo_audio = None
        self.processo_stream = None

        self.instancia = vlc.Instance()
        self.player = self.instancia.media_player_new()

        self.substituicoes_palavras = {
            r'\bdriver\b': "piloto",
            r'Obrigado por assistir!': "        ",
            r'por assistir!': "        ",
            r'\brace car driver\b': "piloto de corrida",
            r'\brace fans\b': "f√£s de corrida",
            r'\bcar\b': "carro",
            r'\bpack\b': "pelot√£o",
            r'\blaps\b': "voltas",
            r'\bObrigado\b': "     ",
            r'!': "     ",
        }

        self.inicializar_arquivo_temp()
        
        # Aguardar para garantir que ambos os arquivos est√£o est√°veis
        time.sleep(0.5)
        
        # Verifica√ß√£o cr√≠tica final na inicializa√ß√£o - SISTEMA DUPLO
        if not os.path.exists(self.caminho_legenda_ffmpeg):
            self.registrar_mensagem("üö® ERRO CR√çTICO: Arquivo FFmpeg n√£o existe ap√≥s inicializa√ß√£o!")
            raise Exception("Falha na inicializa√ß√£o do arquivo FFmpeg")
        
        if not os.path.exists(self.caminho_legenda_write):
            self.registrar_mensagem("üö® ERRO CR√çTICO: Buffer de escrita n√£o existe ap√≥s inicializa√ß√£o!")
            raise Exception("Falha na inicializa√ß√£o do buffer de escrita")
        
        self.registrar_mensagem("‚úÖ Sistema arquivo permanente inicializado com sucesso")

    def inicializar_arquivo_temp(self):
        """Inicializa ARQUIVO PERMANENTE que NUNCA √â DELETADO"""
        with self.trava_arquivo_temp:
            max_tentativas = 10
            for tentativa in range(max_tentativas):
                try:
                    texto_inicial = "  "
                    
                    # ESTRAT√âGIA RADICAL: Criar arquivo que NUNCA ser√° deletado
                    # Apenas CONTE√öDO ser√° modificado, nunca o arquivo em si
                    
                    # ARQUIVO 1: FFmpeg (PERMANENTE)
                    if not os.path.exists(self.caminho_legenda_ffmpeg):
                        with open(self.caminho_legenda_ffmpeg, "w", encoding="utf-8", newline='') as f:
                            f.write(texto_inicial)
                            f.flush()
                            os.fsync(f.fileno())
                        
                        # Definir como somente leitura para FFmpeg, mas com escrita para n√≥s
                        if os.name == 'nt':
                            # Windows: definir permiss√µes especiais
                            os.chmod(self.caminho_legenda_ffmpeg, 0o666)
                    else:
                        # Arquivo j√° existe - apenas atualizar conte√∫do
                        with open(self.caminho_legenda_ffmpeg, "w", encoding="utf-8", newline='') as f:
                            f.write(texto_inicial)
                            f.flush()
                            os.fsync(f.fileno())
                    
                    # ARQUIVO 2: Buffer (PERMANENTE)
                    if not os.path.exists(self.caminho_legenda_write):
                        with open(self.caminho_legenda_write, "w", encoding="utf-8", newline='') as f:
                            f.write(texto_inicial)
                            f.flush()
                            os.fsync(f.fileno())
                        
                        if os.name == 'nt':
                            os.chmod(self.caminho_legenda_write, 0o666)
                    else:
                        # Arquivo j√° existe - apenas atualizar conte√∫do
                        with open(self.caminho_legenda_write, "w", encoding="utf-8", newline='') as f:
                            f.write(texto_inicial)
                            f.flush()
                            os.fsync(f.fileno())
                    
                    # AGUARDAR MAIS TEMPO para garantir que arquivos est√£o est√°veis
                    time.sleep(1.0)
                    
                    # VERIFICA√á√ÉO ULTRA-RIGOROSA
                    arquivos_verificados = 0
                    
                    for arquivo in [self.caminho_legenda_ffmpeg, self.caminho_legenda_write]:
                        for verificacao in range(10):  # 10 verifica√ß√µes por arquivo
                            if not os.path.exists(arquivo):
                                self.registrar_mensagem(f"‚ö†Ô∏è Arquivo {os.path.basename(arquivo)} n√£o existe na verifica√ß√£o {verificacao + 1}")
                                time.sleep(0.2)
                                continue
                                
                            try:
                                with open(arquivo, "r", encoding="utf-8") as f:
                                    conteudo = f.read()
                                    if len(conteudo) == 0:
                                        self.registrar_mensagem(f"‚ö†Ô∏è Arquivo {os.path.basename(arquivo)} vazio na verifica√ß√£o {verificacao + 1}")
                                        time.sleep(0.2)
                                        continue
                            except Exception as e:
                                self.registrar_mensagem(f"‚ö†Ô∏è Erro ao ler {os.path.basename(arquivo)} na verifica√ß√£o {verificacao + 1}: {e}")
                                time.sleep(0.2)
                                continue
                                
                            tamanho = os.path.getsize(arquivo)
                            if tamanho == 0:
                                self.registrar_mensagem(f"‚ö†Ô∏è Arquivo {os.path.basename(arquivo)} tem tamanho 0 na verifica√ß√£o {verificacao + 1}")
                                time.sleep(0.2)
                                continue
                            
                            # Arquivo OK!
                            arquivos_verificados += 1
                            break
                        else:
                            # Todas as 10 verifica√ß√µes falharam para este arquivo
                            raise Exception(f"Arquivo {os.path.basename(arquivo)} falhou em todas as verifica√ß√µes")
                    
                    if arquivos_verificados != 2:
                        raise Exception(f"Apenas {arquivos_verificados}/2 arquivos foram verificados com sucesso")
                    
                    # TESTE FINAL ESPEC√çFICO PARA FFMPEG
                    try:
                        # Simular exatamente o que o FFmpeg vai fazer
                        with open(self.caminho_legenda_ffmpeg, "r", encoding="utf-8") as f:
                            conteudo_ffmpeg_test = f.read()
                            if not conteudo_ffmpeg_test:
                                raise Exception("FFmpeg test: arquivo vazio")
                        
                        # Verificar se o arquivo est√° "travado" por algum processo
                        try:
                            with open(self.caminho_legenda_ffmpeg, "a", encoding="utf-8") as f:
                                pass  # Apenas teste de escrita
                        except Exception as e:
                            self.registrar_mensagem(f"‚ö†Ô∏è Arquivo pode estar travado: {e}")
                        
                    except Exception as e:
                        raise Exception(f"Teste espec√≠fico FFmpeg falhou: {e}")
                    
                    # CRIAR BACKUPS
                    backups_criados = self.criar_arquivos_backup(texto_inicial)
                    
                    self.registrar_mensagem(f"‚úÖ ARQUIVO PERMANENTE criado:")
                    self.registrar_mensagem(f"   üìñ FFmpeg (NUNCA deletado): {self.caminho_legenda_ffmpeg}")
                    self.registrar_mensagem(f"   ‚úèÔ∏è Buffer (NUNCA deletado): {self.caminho_legenda_write}")
                    self.registrar_mensagem(f"   üõ°Ô∏è Backups: {len(backups_criados)}/{len(self.arquivos_backup)}")
                    self.registrar_mensagem(f"   üîç Verifica√ß√µes: {arquivos_verificados}/2 arquivos OK")
                    
                    # Inicializar timestamp de sincroniza√ß√£o
                    self.ultima_sincronizacao = time.time()
                    
                    # Reset contador de falhas
                    self.falhas_consecutivas = 0
                    return True
                    
                except Exception as e:
                    self.falhas_consecutivas += 1
                    self.registrar_mensagem(f"‚ùå Tentativa {tentativa + 1}/{max_tentativas} de arquivo permanente falhou: {e}")
                    
                    # Se falhou, remover arquivos problem√°ticos e tentar novamente
                    for arquivo in [self.caminho_legenda_ffmpeg, self.caminho_legenda_write]:
                        try:
                            if os.path.exists(arquivo):
                                os.remove(arquivo)
                        except:
                            pass
                    
                    if tentativa < max_tentativas - 1:
                        time.sleep(2.0)  # Esperar mais tempo entre tentativas
                    
            # Se chegou aqui, todas as tentativas falharam
            self.registrar_mensagem("üö® ERRO CR√çTICO: N√£o foi poss√≠vel criar arquivo permanente")
            return False

    def criar_arquivos_backup(self, conteudo="    "):
        """Cria m√∫ltiplos arquivos de backup para prevenir remo√ß√£o por antiv√≠rus/sistema"""
        sucesso = []
        
        for i, arquivo_backup in enumerate(self.arquivos_backup):
            try:
                # Criar diret√≥rio se n√£o existir
                dir_backup = os.path.dirname(arquivo_backup)
                if dir_backup and not os.path.exists(dir_backup):
                    os.makedirs(dir_backup, exist_ok=True)
                
                with open(arquivo_backup, "w", encoding="utf-8", newline='') as f:
                    f.write(conteudo)
                    f.flush()
                    os.fsync(f.fileno())
                
                # Verificar se foi criado
                if os.path.exists(arquivo_backup) and os.path.getsize(arquivo_backup) > 0:
                    sucesso.append(i)
                    if os.name == 'nt':
                        os.chmod(arquivo_backup, 0o666)
                        
            except Exception as e:
                self.registrar_mensagem(f"‚ö†Ô∏è Falha ao criar backup {i}: {e}")
        
        return sucesso

    def verificar_arquivo_principal_e_backups(self):
        """Verifica arquivo principal e todos os backups"""
        # Verificar arquivo principal
        principal_ok = False
        try:
            if os.path.exists(self.caminho_legenda_temp):
                with open(self.caminho_legenda_temp, "r", encoding="utf-8") as f:
                    conteudo = f.read()
                    if len(conteudo) > 0:
                        principal_ok = True
        except:
            pass
        
        # Verificar backups
        backups_ok = []
        for i, arquivo_backup in enumerate(self.arquivos_backup):
            try:
                if os.path.exists(arquivo_backup):
                    with open(arquivo_backup, "r", encoding="utf-8") as f:
                        conteudo = f.read()
                        if len(conteudo) > 0:
                            backups_ok.append(i)
            except:
                pass
        
        return principal_ok, backups_ok

    def verificar_integridade_arquivo(self):
        """Verifica se AMBOS os arquivos do sistema duplo est√£o √≠ntegros"""
        try:
            # Verificar arquivo FFmpeg (principal)
            ffmpeg_ok = False
            if os.path.exists(self.caminho_legenda_ffmpeg):
                with open(self.caminho_legenda_ffmpeg, "r", encoding="utf-8") as f:
                    conteudo = f.read()
                    if len(conteudo) >= 0:  # Aceita arquivo vazio
                        ffmpeg_ok = True
            
            # Verificar buffer de escrita
            buffer_ok = False
            if os.path.exists(self.caminho_legenda_write):
                with open(self.caminho_legenda_write, "r", encoding="utf-8") as f:
                    conteudo = f.read()
                    if len(conteudo) >= 0:  # Aceita arquivo vazio
                        buffer_ok = True
            
            # Ambos devem estar OK
            return ffmpeg_ok and buffer_ok
            
        except Exception as e:
            self.registrar_mensagem(f"Sistema duplo arquivo corrompido: {e}")
            return False

    def verificar_arquivo_principal_e_backups(self):
        """Verifica arquivos principais e backups do sistema duplo"""
        # Verificar ambos os arquivos principais
        ffmpeg_ok = False
        buffer_ok = False
        
        try:
            if os.path.exists(self.caminho_legenda_ffmpeg):
                with open(self.caminho_legenda_ffmpeg, "r", encoding="utf-8") as f:
                    conteudo = f.read()
                    if len(conteudo) > 0:
                        ffmpeg_ok = True
        except:
            pass
        
        try:
            if os.path.exists(self.caminho_legenda_write):
                with open(self.caminho_legenda_write, "r", encoding="utf-8") as f:
                    conteudo = f.read()
                    if len(conteudo) > 0:
                        buffer_ok = True
        except:
            pass
        
        # Para compatibilidade, consideramos principal_ok se pelo menos o FFmpeg estiver OK
        principal_ok = ffmpeg_ok
        
        # Verificar backups
        backups_ok = []
        for i, arquivo_backup in enumerate(self.arquivos_backup):
            try:
                if os.path.exists(arquivo_backup):
                    with open(arquivo_backup, "r", encoding="utf-8") as f:
                        conteudo = f.read()
                        if len(conteudo) > 0:
                            backups_ok.append(i)
            except:
                pass
        
        return principal_ok, backups_ok

    def guardian_do_arquivo(self):
        """Thread GUARDI√ÉO ULTRA-AGRESSIVO para ARQUIVOS PERMANENTES"""
        self.registrar_mensagem("üëÆ GUARDI√ÉO ARQUIVO PERMANENTE iniciado (verifica√ß√£o a cada 0.5s)")
        
        while self.em_execucao:
            try:
                # VERIFICA√á√ÉO CR√çTICA 1: Arquivo FFmpeg (NUNCA pode desaparecer)
                if not os.path.exists(self.caminho_legenda_ffmpeg):
                    self.registrar_mensagem("üö® GUARDI√ÉO: ARQUIVO FFMPEG DESAPARECEU! EMERG√äNCIA!")
                    
                    # PARAR FFmpeg imediatamente para evitar erros
                    if hasattr(self, 'processo_stream') and self.processo_stream:
                        try:
                            self.processo_stream.terminate()
                            self.registrar_mensagem("üõë FFmpeg interrompido devido ao arquivo perdido")
                        except:
                            pass
                    
                    # RECRIAR arquivo FFmpeg IMEDIATAMENTE
                    conteudo_emergencia = "       "
                    
                    # Tentar usar conte√∫do do buffer se existir
                    if os.path.exists(self.caminho_legenda_write):
                        try:
                            with open(self.caminho_legenda_write, "r", encoding="utf-8") as f:
                                conteudo_buffer = f.read()
                                if conteudo_buffer:
                                    conteudo_emergencia = conteudo_buffer
                        except:
                            pass
                    
                    # Usar √∫ltima legenda conhecida se dispon√≠vel
                    if self.ultimo_texto_legenda:
                        conteudo_emergencia = self.ultimo_texto_legenda
                    
                    # RECRIAR arquivo FFmpeg
                    try:
                        with open(self.caminho_legenda_ffmpeg, "w", encoding="utf-8", newline='') as f:
                            f.write(conteudo_emergencia)
                            f.flush()
                            os.fsync(f.fileno())
                        
                        # Definir permiss√µes
                        if os.name == 'nt':
                            os.chmod(self.caminho_legenda_ffmpeg, 0o666)
                        
                        # VERIFICAR se foi criado corretamente
                        time.sleep(0.1)
                        if os.path.exists(self.caminho_legenda_ffmpeg):
                            with open(self.caminho_legenda_ffmpeg, "r", encoding="utf-8") as f:
                                if f.read():
                                    self.registrar_mensagem("üëÆ GUARDI√ÉO: ARQUIVO FFMPEG RESTAURADO!")
                                    
                                    # REINICIAR FFmpeg se necess√°rio
                                    if hasattr(self, 'processo_stream') and self.processo_stream:
                                        if self.processo_stream.poll() is not None:  # Processo terminou
                                            try:
                                                self.processo_stream = self.iniciar_stream()
                                                self.registrar_mensagem("üîÑ FFmpeg reiniciado automaticamente")
                                            except Exception as e:
                                                self.registrar_mensagem(f"‚ùå Erro ao reiniciar FFmpeg: {e}")
                                else:
                                    self.registrar_mensagem("üëÆ GUARDI√ÉO: Arquivo FFmpeg criado mas est√° vazio!")
                        else:
                            self.registrar_mensagem("üëÆ GUARDI√ÉO: FALHA ao criar arquivo FFmpeg!")
                            
                    except Exception as e:
                        self.registrar_mensagem(f"üëÆ GUARDI√ÉO: ERRO CR√çTICO ao restaurar FFmpeg - {e}")
                
                # VERIFICA√á√ÉO 2: Buffer de escrita
                if not os.path.exists(self.caminho_legenda_write):
                    self.registrar_mensagem("üëÆ GUARDI√ÉO: Buffer perdido - recriando...")
                    
                    conteudo_buffer = self.ultimo_texto_legenda or "      "
                    try:
                        with open(self.caminho_legenda_write, "w", encoding="utf-8", newline='') as f:
                            f.write(conteudo_buffer)
                            f.flush()
                            os.fsync(f.fileno())
                        
                        if os.name == 'nt':
                            os.chmod(self.caminho_legenda_write, 0o666)
                        
                        self.registrar_mensagem("üëÆ GUARDI√ÉO: Buffer recriado")
                    except Exception as e:
                        self.registrar_mensagem(f"üëÆ GUARDI√ÉO: ERRO no buffer - {e}")
                
                # VERIFICA√á√ÉO 3: Integridade dos arquivos
                for nome, arquivo in [("FFmpeg", self.caminho_legenda_ffmpeg), ("Buffer", self.caminho_legenda_write)]:
                    if os.path.exists(arquivo):
                        try:
                            tamanho = os.path.getsize(arquivo)
                            if tamanho == 0:
                                # Arquivo vazio - preencher IMEDIATAMENTE
                                conteudo_default = self.ultimo_texto_legenda or "        "
                                with open(arquivo, "w", encoding="utf-8", newline='') as f:
                                    f.write(conteudo_default)
                                    f.flush()
                                    os.fsync(f.fileno())
                                self.registrar_mensagem(f"üëÆ GUARDI√ÉO: {nome} estava vazio - preenchido")
                        except Exception as e:
                            self.registrar_mensagem(f"üëÆ GUARDI√ÉO: Erro ao verificar {nome}: {e}")
                
                # VERIFICA√á√ÉO 4: Sincroniza√ß√£o entre arquivos (mais frequente)
                if os.path.exists(self.caminho_legenda_ffmpeg) and os.path.exists(self.caminho_legenda_write):
                    try:
                        self.sincronizar_arquivos()
                    except Exception as e:
                        self.registrar_mensagem(f"üëÆ GUARDI√ÉO: Erro na sincroniza√ß√£o: {e}")
                
                # Verifica√ß√£o MUITO frequente - a cada 0.5 segundos
                time.sleep(0.5)
                
            except Exception as e:
                self.registrar_mensagem(f"üëÆ GUARDI√ÉO: Erro cr√≠tico - {e}")
                time.sleep(0.2)  # Continuar mesmo com erro, mas mais frequente

    def restaurar_de_backup(self):
        """Restaura arquivo principal a partir de backup dispon√≠vel"""
        principal_ok, backups_ok = self.verificar_arquivo_principal_e_backups()
        
        if not principal_ok and backups_ok:
            # Usar o primeiro backup dispon√≠vel
            backup_indice = backups_ok[0]
            arquivo_backup = self.arquivos_backup[backup_indice]
            
            try:
                with open(arquivo_backup, "r", encoding="utf-8") as f:
                    conteudo = f.read()
                
                with open(self.caminho_legenda_temp, "w", encoding="utf-8", newline='') as f:
                    f.write(conteudo)
                    f.flush()
                    os.fsync(f.fileno())
                
                self.registrar_mensagem(f"‚úÖ Arquivo principal restaurado do backup {backup_indice}")
                return True
                
            except Exception as e:
                self.registrar_mensagem(f"‚ùå Falha ao restaurar do backup {backup_indice}: {e}")
        
        return False

    def monitorar_arquivo_temp(self):
        """Thread para monitoramento ULTRA-ROBUSTO do arquivo tempor√°rio"""
        self.registrar_mensagem("üõ°Ô∏è Monitor de arquivo ULTRA-ROBUSTO iniciado")
        
        ciclo = 0
        ultimo_heartbeat = time.time()
        
        while self.em_execucao:
            try:
                ciclo += 1
                agora = time.time()
                
                # VERIFICA√á√ÉO B√ÅSICA A CADA CICLO (30 segundos)
                principal_ok, backups_ok = self.verificar_arquivo_principal_e_backups()
                
                if not principal_ok:
                    self.registrar_mensagem(f"üö® ALERTA CICLO {ciclo}: Arquivo principal PERDIDO ap√≥s {(agora - ultimo_heartbeat):.1f}s")
                    
                    # Tentar restaurar de backup primeiro
                    if self.restaurar_de_backup():
                        self.registrar_mensagem("‚úÖ Arquivo restaurado de backup com sucesso")
                    else:
                        # Se n√£o conseguiu restaurar, recriar completamente
                        self.registrar_mensagem("‚ö†Ô∏è Recriando arquivo do zero...")
                        with self.trava_arquivo_temp:
                            if not self.inicializar_arquivo_temp():
                                self.registrar_mensagem("üö® FALHA CR√çTICA: N√£o foi poss√≠vel recriar arquivo!")
                                # Tentar com nome alternativo
                                timestamp = int(time.time())
                                self.caminho_legenda_temp = os.path.join(
                                    tempfile.gettempdir(), 
                                    f"legenda_emergency_{timestamp}.txt"
                                )
                                if not self.inicializar_arquivo_temp():
                                    self.registrar_mensagem("üíÄ ERRO FATAL: Sistema de recupera√ß√£o falhou completamente")
                                else:
                                    self.registrar_mensagem(f"üÜò Arquivo de emerg√™ncia criado: {self.caminho_legenda_temp}")
                            else:
                                self.registrar_mensagem("‚úÖ Arquivo recriado com sucesso")
                else:
                    # Arquivo OK - verificar se n√£o est√° muito velho (mais de 5 minutos sem update)
                    if agora - self.ultimo_update > 300:  # 5 minutos
                        self.registrar_mensagem(f"‚è∞ Arquivo sem update h√° {(agora - self.ultimo_update):.1f}s - fazendo refresh...")
                        try:
                            # Recriar o arquivo proativamente para evitar corrup√ß√£o
                            conteudo_atual = "      "
                            if self.ultimo_texto_legenda:
                                conteudo_atual = self.ultimo_texto_legenda
                            
                            with self.trava_arquivo_temp:
                                with open(self.caminho_legenda_temp, "w", encoding="utf-8", newline='') as f:
                                    f.write(conteudo_atual)
                                    f.flush()
                                    os.fsync(f.fileno())
                                
                                # Atualizar backups tamb√©m
                                self.criar_arquivos_backup(conteudo_atual)
                                
                            self.ultimo_update = agora
                            self.registrar_mensagem("‚úÖ Refresh proativo conclu√≠do")
                        except Exception as e:
                            self.registrar_mensagem(f"‚ùå Erro no refresh proativo: {e}")
                
                # HEARTBEAT - verifica√ß√£o extra a cada minuto
                if agora - ultimo_heartbeat > 60:  # 1 minuto
                    principal_ok_heart, backups_ok_heart = self.verificar_arquivo_principal_e_backups()
                    self.registrar_mensagem(f"üíì HEARTBEAT {ciclo}: Principal={'‚úÖ' if principal_ok_heart else '‚ùå'} | Backups={len(backups_ok_heart)}/{len(self.arquivos_backup)}")
                    
                    if principal_ok_heart:
                        try:
                            tamanho = os.path.getsize(self.caminho_legenda_temp)
                            with open(self.caminho_legenda_temp, "r", encoding="utf-8") as f:
                                amostra = f.read()[:50]
                            self.registrar_mensagem(f"üìä Status: {tamanho} bytes | '{amostra}...'")
                        except:
                            self.registrar_mensagem("‚ö†Ô∏è Erro ao ler detalhes do arquivo")
                    
                    ultimo_heartbeat = agora
                
                # RECREA√á√ÉO PREVENTIVA a cada 10 minutos (para evitar corrup√ß√£o por uso prolongado)
                if ciclo % 20 == 0:  # A cada 20 ciclos (10 minutos se ciclo = 30s)
                    self.registrar_mensagem("üîÑ MANUTEN√á√ÉO PREVENTIVA - recriando arquivo...")
                    try:
                        conteudo_preventivo = self.ultimo_texto_legenda or "       "
                        with self.trava_arquivo_temp:
                            # Recriar arquivo principal
                            with open(self.caminho_legenda_temp, "w", encoding="utf-8", newline='') as f:
                                f.write(conteudo_preventivo)
                                f.flush()
                                os.fsync(f.fileno())
                            
                            # Recriar todos os backups
                            backups_recriados = self.criar_arquivos_backup(conteudo_preventivo)
                            
                        self.registrar_mensagem(f"‚úÖ Manuten√ß√£o preventiva OK - {len(backups_recriados)} backups recriados")
                    except Exception as e:
                        self.registrar_mensagem(f"‚ùå Erro na manuten√ß√£o preventiva: {e}")
                
                time.sleep(30)  # Verificar a cada 30 segundos
                
            except Exception as e:
                self.registrar_mensagem(f"‚ùå Erro no monitoramento: {e}")
                time.sleep(5)  # Em caso de erro, aguardar menos tempo

    def registrar_mensagem(self, mensagem):
        """Registra mensagem com timestamp de forma thread-safe"""
        timestamp = time.strftime('%H:%M:%S')
        print(f"{timestamp} - {mensagem}")

    def iniciar_captura_audio(self):
        """Inicia captura de √°udio do stream RTMP"""
        comando_ffmpeg = [
            "ffmpeg", "-i", self.entrada_rtmp,
            "-vn", "-acodec", "pcm_s16le", "-ar", "16000", "-ac", "1",
            "-f", "s16le", "pipe:1"
        ]
        return subprocess.Popen(
            comando_ffmpeg,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            bufsize=10**8
        )

    def obter_comando_ffmpeg(self):
        """Constr√≥i comando FFmpeg com verifica√ß√£o ULTRA-ROBUSTA"""
        efeito_total_legenda = self.atraso_video + self.atraso_legenda
        
        # VERIFICA√á√ÉO CR√çTICA: Garantir que o arquivo existe e √© leg√≠vel ANTES de usar no FFmpeg
        max_tentativas = 10  # Aumentei para 10 tentativas
        for tentativa in range(max_tentativas):
            arquivo_ok = False
            
            # Verifica√ß√£o 1: Arquivo existe?
            if not os.path.exists(self.caminho_legenda_temp):
                self.registrar_mensagem(f"‚ö†Ô∏è Arquivo n√£o existe antes do FFmpeg (tentativa {tentativa + 1}) - recriando...")
                with self.trava_arquivo_temp:
                    if not self.inicializar_arquivo_temp():
                        if tentativa == max_tentativas - 1:
                            raise Exception("ERRO CR√çTICO: N√£o foi poss√≠vel criar arquivo para FFmpeg")
                        time.sleep(1.0)  # Esperar mais tempo
                        continue
            
            # Verifica√ß√£o 2: Arquivo √© leg√≠vel?
            try:
                with open(self.caminho_legenda_temp, "r", encoding="utf-8") as f:
                    conteudo = f.read()
                    if not conteudo:
                        raise Exception("Arquivo vazio")
                arquivo_ok = True
            except Exception as e:
                self.registrar_mensagem(f"‚ö†Ô∏è Arquivo n√£o leg√≠vel (tentativa {tentativa + 1}): {e}")
                
                # Tentar restaurar de backup
                if self.restaurar_de_backup():
                    self.registrar_mensagem("‚úÖ Arquivo restaurado de backup para FFmpeg")
                    continue
                else:
                    # Recriar arquivo
                    with self.trava_arquivo_temp:
                        if not self.inicializar_arquivo_temp():
                            if tentativa == max_tentativas - 1:
                                raise Exception("ERRO CR√çTICO: Arquivo n√£o leg√≠vel para FFmpeg")
                            time.sleep(1.0)
                            continue
            
            # Verifica√ß√£o 3: Arquivo tem tamanho adequado?
            try:
                tamanho = os.path.getsize(self.caminho_legenda_temp)
                if tamanho == 0:
                    raise Exception("Arquivo com tamanho zero")
            except Exception as e:
                self.registrar_mensagem(f"‚ö†Ô∏è Problema com tamanho do arquivo: {e}")
                with self.trava_arquivo_temp:
                    if not self.inicializar_arquivo_temp():
                        if tentativa == max_tentativas - 1:
                            raise Exception("ERRO CR√çTICO: Problema com tamanho do arquivo")
                        time.sleep(1.0)
                        continue
            
            # Verifica√ß√£o 4: Teste de leitura completo
            try:
                with open(self.caminho_legenda_temp, "r", encoding="utf-8") as f:
                    conteudo_teste = f.read()
                    if len(conteudo_teste) < 1:
                        raise Exception("Conte√∫do insuficiente")
                
                self.registrar_mensagem(f"‚úÖ Arquivo verificado para FFmpeg (tentativa {tentativa + 1}): '{conteudo_teste[:30]}...'")
                break
                
            except Exception as e:
                self.registrar_mensagem(f"‚ö†Ô∏è Teste final falhou (tentativa {tentativa + 1}): {e}")
                if tentativa == max_tentativas - 1:
                    raise Exception("ERRO CR√çTICO: Teste final de leitura falhou")
                
                # √öltima tentativa de corre√ß√£o
                with self.trava_arquivo_temp:
                    self.inicializar_arquivo_temp()
                time.sleep(1.0)
        
        self.registrar_mensagem(f"Configura√ß√£o do stream:")
        self.registrar_mensagem(f"- V√≠deo/√°udio atrasado em: {self.atraso_video}s")
        self.registrar_mensagem(f"- Legendas com delay: {self.atraso_legenda}s")
        self.registrar_mensagem(f"- Efeito final: legendas aparecem {abs(efeito_total_legenda)}s {'antes' if efeito_total_legenda < 0 else 'depois'} do v√≠deo no output")

        fonte_netflix = "C:/Users/Yp√™TV/Desktop/LEGENDA/fonts/NetflixSans-Bold.otf"
        fonte_alternativa = "C:/Users/Yp√™TV/Desktop/LEGENDA/fonts/arial.ttf" if os.name == 'nt' else "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"
        caminho_fonte = fonte_netflix if os.path.exists(fonte_netflix) else fonte_alternativa
        
        # Escapar caminhos adequadamente para FFmpeg
        caminho_fonte_seguro = caminho_fonte.replace("\\", "/").replace(":", "\\:")
        caminho_legenda_seguro = self.caminho_legenda_temp.replace("\\", "/").replace(":", "\\:")
        
        self.registrar_mensagem(f"üìÅ Arquivo de legenda: {self.caminho_legenda_temp}")
        self.registrar_mensagem(f"üìÅ Caminho seguro para FFmpeg: {caminho_legenda_seguro}")

        return [
            "ffmpeg",
            "-re",
            "-i", self.entrada_rtmp,
            "-filter_complex", 
            f"[0:v]drawtext=fontfile='{caminho_fonte_seguro}':"
            f"textfile='{caminho_legenda_seguro}':"
            f"fontsize=42:"
            f"fontcolor=yellow:"
            f"bordercolor=black:"
            f"borderw=3:"
            f"x=(w-tw)/2:"
            f"y=h-th-70:"
            f"line_spacing=-30:"
            f"reload=1:"          # Importante: recarrega o arquivo
            f"text_align=center:"
            f"fix_bounds=1[vout]",
            "-map", "[vout]",
            "-map", "0:a",
            "-c:v", "libx264",
            "-preset", "ultrafast",
            "-tune", "zerolatency",  # Adicionar para streaming
            "-c:a", "aac",
            "-b:a", "128k",
            "-output_ts_offset", str(self.atraso_video),
            "-f", "flv",
            "-avoid_negative_ts", "make_zero",
            "-loglevel", "error",    # Reduzir logs desnecess√°rios
            self.saida_rtmp
        ]

    def iniciar_stream(self):
        """Inicia stream de v√≠deo com legendas"""
        comando = self.obter_comando_ffmpeg()
        return subprocess.Popen(comando)

    def definir_atrasos(self, atraso_video_segundos, atraso_legenda_segundos):
        """Define atrasos de v√≠deo e legenda de forma thread-safe"""
        with self.trava_legenda:
            try:
                self.atraso_video = float(atraso_video_segundos)
                self.atraso_legenda = float(atraso_legenda_segundos)
                
                efeito_total = self.atraso_video + self.atraso_legenda
                
                self.registrar_mensagem(f"Nova configura√ß√£o:")
                self.registrar_mensagem(f"- V√≠deo/√°udio: {self.atraso_video}s de atraso")
                self.registrar_mensagem(f"- Legendas: {self.atraso_legenda}s de delay")
                self.registrar_mensagem(f"- Resultado: legendas {abs(efeito_total)}s {'adiantadas' if efeito_total < 0 else 'atrasadas'} em rela√ß√£o ao v√≠deo")

                if self.em_execucao and self.processo_stream:
                    self.registrar_mensagem("Para aplicar as novas configura√ß√µes, reinicie a tradu√ß√£o")
            except ValueError as e:
                self.registrar_mensagem(f"Valores inv√°lidos: {e}")

    def definir_atraso_video(self, atraso_segundos):
        """Define apenas o atraso do v√≠deo/√°udio"""
        self.definir_atrasos(atraso_segundos, self.atraso_legenda)

    def definir_atraso_legenda(self, atraso_segundos):
        """Define apenas o delay das legendas"""
        self.definir_atrasos(self.atraso_video, atraso_segundos)

    def sincronizar_arquivos(self):
        """Sincroniza CONTE√öDO (NUNCA deleta/recria arquivo)"""
        agora = time.time()
        
        # S√≥ sincronizar se passou o intervalo m√≠nimo
        if agora - self.ultima_sincronizacao < self.intervalo_sincronizacao:
            return True
        
        try:
            # Verificar se ambos os arquivos existem (cr√≠tico)
            if not os.path.exists(self.caminho_legenda_write):
                self.registrar_mensagem("üö® SINCRONIZA√á√ÉO: Buffer n√£o existe!")
                return False
                
            if not os.path.exists(self.caminho_legenda_ffmpeg):
                self.registrar_mensagem("üö® SINCRONIZA√á√ÉO: Arquivo FFmpeg n√£o existe!")
                return False
            
            # Ler conte√∫do do buffer de escrita
            with open(self.caminho_legenda_write, "r", encoding="utf-8") as f:
                conteudo_buffer = f.read()
            
            # Verificar se o arquivo do FFmpeg precisa de atualiza√ß√£o
            conteudo_ffmpeg = ""
            try:
                with open(self.caminho_legenda_ffmpeg, "r", encoding="utf-8") as f:
                    conteudo_ffmpeg = f.read()
            except:
                pass  # Se n√£o conseguir ler, vamos sobrescrever
            
            # S√≥ atualizar se o conte√∫do for diferente
            if conteudo_buffer != conteudo_ffmpeg:
                # ESTRAT√âGIA NOVA: NUNCA usar arquivo tempor√°rio
                # APENAS sobrescrever o CONTE√öDO diretamente
                
                # M√âTODO MAIS SEGURO: Usar SEEK para sobrescrever
                try:
                    with open(self.caminho_legenda_ffmpeg, "r+", encoding="utf-8") as f:
                        f.seek(0)  # Ir para o in√≠cio
                        f.write(conteudo_buffer)
                        f.truncate()  # Remover conte√∫do extra se o novo for menor
                        f.flush()
                        os.fsync(f.fileno())
                except:
                    # Se r+ falhar, usar w (pode ser problem√°tico mas √© backup)
                    with open(self.caminho_legenda_ffmpeg, "w", encoding="utf-8", newline='') as f:
                        f.write(conteudo_buffer)
                        f.flush()
                        os.fsync(f.fileno())
                
                # Verificar se sincroniza√ß√£o foi bem-sucedida
                try:
                    with open(self.caminho_legenda_ffmpeg, "r", encoding="utf-8") as f:
                        verificacao_pos_sync = f.read()
                        if verificacao_pos_sync != conteudo_buffer:
                            self.registrar_mensagem("‚ö†Ô∏è Sincroniza√ß√£o falhou - conte√∫do diferente")
                            return False
                except:
                    self.registrar_mensagem("‚ö†Ô∏è Sincroniza√ß√£o falhou - erro na verifica√ß√£o")
                    return False
            
            self.ultima_sincronizacao = agora
            return True
            
        except Exception as e:
            self.registrar_mensagem(f"‚ö†Ô∏è Erro na sincroniza√ß√£o: {e}")
            return False

    def atualizar_legenda_temp(self, texto_formatado):
        """Atualiza BUFFER PERMANENTE (NUNCA deleta arquivo)"""
        with self.trava_arquivo_temp:
            max_tentativas = 3
            tentativa = 0
            
            # Atualizar timestamp e contador
            self.ultimo_update = time.time()
            self.contador_updates += 1
            
            while tentativa < max_tentativas:
                try:
                    # Verificar se buffer existe (cr√≠tico)
                    if not os.path.exists(self.caminho_legenda_write):
                        self.registrar_mensagem("‚ö†Ô∏è Buffer permanente n√£o existe - PROBLEMA CR√çTICO!")
                        # Tentar recriar apenas o buffer sem afetar FFmpeg
                        conteudo_emergencia = texto_formatado if texto_formatado else "       "
                        with open(self.caminho_legenda_write, "w", encoding="utf-8", newline='') as f:
                            f.write(conteudo_emergencia)
                            f.flush()
                            os.fsync(f.fileno())
                        self.registrar_mensagem("‚úÖ Buffer permanente recriado")
                    
                    conteudo_final = texto_formatado if texto_formatado else "        "
                    
                    # ESCRITA DIRETA NO BUFFER (arquivo permanente)
                    # M√âTODO 1: Tentar r+ (mais seguro)
                    try:
                        with open(self.caminho_legenda_write, "r+", encoding="utf-8") as f:
                            f.seek(0)  # Ir para o in√≠cio
                            f.write(conteudo_final)
                            f.truncate()  # Remover conte√∫do extra se necess√°rio
                            f.flush()
                            os.fsync(f.fileno())
                    except:
                        # M√âTODO 2: Se r+ falhar, usar w (menos ideal)
                        with open(self.caminho_legenda_write, "w", encoding="utf-8", newline='') as f:
                            f.write(conteudo_final)
                            f.flush()
                            os.fsync(f.fileno())
                    
                    # Verifica√ß√£o IMEDIATA do buffer
                    with open(self.caminho_legenda_write, "r", encoding="utf-8") as f:
                        verificacao_imediata = f.read()
                        if verificacao_imediata != conteudo_final:
                            raise Exception("Verifica√ß√£o do buffer permanente falhou")
                    
                    # SINCRONIZA√á√ÉO autom√°tica ser√° feita pelo guardi√£o
                    # N√£o fazemos aqui para n√£o atrasar
                    
                    # Reset contador de falhas
                    self.falhas_consecutivas = 0
                    
                    # Log ocasional para n√£o spam
                    if self.contador_updates % 50 == 0:
                        self.registrar_mensagem(f"üìä Update #{self.contador_updates}: buffer permanente OK")
                    
                    return True
                    
                except Exception as e:
                    tentativa += 1
                    self.falhas_consecutivas += 1
                    self.registrar_mensagem(f"‚ö†Ô∏è Tentativa {tentativa}/{max_tentativas} no buffer permanente falhou: {e}")
                    
                    if tentativa < max_tentativas:
                        time.sleep(0.2 * tentativa)  # Delay progressivo
                    else:
                        self.registrar_mensagem(f"üö® FALHA TOTAL no buffer permanente ap√≥s {max_tentativas} tentativas")
                        
                        # √öLTIMO RECURSO: Recriar buffer permanente
                        try:
                            self.registrar_mensagem("üÜò √öLTIMO RECURSO: Recriando buffer permanente...")
                            
                            # Remover buffer problem√°tico
                            if os.path.exists(self.caminho_legenda_write):
                                os.remove(self.caminho_legenda_write)
                            
                            # Recriar buffer
                            with open(self.caminho_legenda_write, "w", encoding="utf-8", newline='') as f:
                                f.write(conteudo_final)
                                f.flush()
                                os.fsync(f.fileno())
                            
                            # Verificar se funcionou
                            with open(self.caminho_legenda_write, "r", encoding="utf-8") as f:
                                if f.read() == conteudo_final:
                                    self.registrar_mensagem("‚úÖ Buffer permanente recriado com sucesso")
                                    return True
                            
                            self.registrar_mensagem("üíÄ Recria√ß√£o do buffer falhou")
                            return False
                            
                        except Exception as ultimo_erro:
                            self.registrar_mensagem(f"üíÄ √öLTIMO RECURSO falhou: {ultimo_erro}")
                            return False
            
            return False

    def processar_legenda(self, texto):
        """Processa legenda para exibi√ß√£o tempor√°ria no stream"""
        with self.trava_legenda:
            texto_limpo = texto.strip()

            if not texto_limpo:
                texto_limpo = " "

            if re.search(r'\bpor assistir\b', texto_limpo, re.IGNORECASE) or \
               re.search(r'\bobrigado por assistir\b', texto_limpo, re.IGNORECASE):
                self.registrar_mensagem("Legenda ignorada (cont√©m 'por assistir')")
                return

            if self.ultimo_texto_legenda == texto_limpo:
                return

            self.ultimo_texto_legenda = texto_limpo

            palavras = texto_limpo.split()
            linhas = []
            linha_atual = ""

            for palavra in palavras:
                if len(linha_atual) + len(palavra) + 1 <= 35:
                    linha_atual = f"{linha_atual} {palavra}" if linha_atual else palavra
                else:
                    linhas.append(linha_atual.center(35))
                    linha_atual = palavra

            if linha_atual:
                linhas.append(linha_atual.center(35))

            texto_formatado = '\n'.join(linhas).replace('%', ' por cento')

            self.atualizar_legenda_temp(texto_formatado)

            self.registrar_mensagem(f"LEGENDA: {texto_formatado}")

    def substituir_palavras(self, texto):
        """Aplica substitui√ß√µes de palavras configuradas"""
        for padrao, substituicao in self.substituicoes_palavras.items():
            texto = re.sub(padrao, substituicao, texto, flags=re.IGNORECASE)
        return texto

    async def processar_audio(self):
        """Processa √°udio de forma ass√≠ncrona com sincroniza√ß√£o adequada"""
        buffer = b""
        TAMANHO_CHUNK = 4096

        while self.em_execucao:
            with self.trava_processamento:
                try:
                    dados = self.processo_audio.stdout.read(TAMANHO_CHUNK)
                    if not dados:
                        await asyncio.sleep(0.01)
                        continue
                    buffer += dados

                    if len(buffer) >= 16000 * 2 * 2:
                        audio_np = np.frombuffer(buffer, dtype=np.int16).astype(np.float32) / 32768.0
                        buffer = b""

                        codigo_idioma_whisper = self.idiomas_whisper.get(self.idioma_whisper)

                        try:
                            segmentos, info = self.modelo.transcribe(audio_np, language=codigo_idioma_whisper)
                            transcricao = " ".join([segmento.text for segmento in segmentos]).strip()
                            self.ultima_transcricao = transcricao
                        except Exception as e:
                            self.registrar_mensagem(f"Erro na transcri√ß√£o: {e}")
                            continue

                        if not transcricao or len(transcricao.split()) < 2:
                            self.processar_legenda("")
                            continue

                        try:
                            codigo_idioma_traducao = self.idiomas_traducao.get(self.traduzir_para_idioma)
                            idioma_origem = codigo_idioma_whisper if codigo_idioma_whisper else 'auto'
                            traducao = self.tradutor.translate(transcricao, src=idioma_origem, dest=codigo_idioma_traducao).text
                            traducao = self.substituir_palavras(traducao)

                            self.processar_legenda(traducao)
                            self.registrar_mensagem(f"Traduzido: {traducao[:50]}...")
                        except Exception as e:
                            self.registrar_mensagem(f"Erro na tradu√ß√£o: {e}")

                except Exception as e:
                    self.registrar_mensagem(f"Erro no processamento de √°udio: {e}")
                    
            await asyncio.sleep(0.01)

    def executar_loop_assincrono(self):
        """Executa loop ass√≠ncrono de processamento"""
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)
        try:
            self.loop.run_until_complete(self.processar_audio())
        except Exception as e:
            self.registrar_mensagem(f"Erro no loop ass√≠ncrono: {e}")
        finally:
            self.loop.close()

    def reiniciar_stream(self):
        """Reinicia o stream com as configura√ß√µes atuais"""
        if not self.em_execucao:
            self.registrar_mensagem("Stream n√£o est√° em execu√ß√£o")
            return False

        with self.trava_legenda:
            if self.processo_stream:
                self.processo_stream.terminate()
                self.processo_stream.wait()

            self.processo_stream = self.iniciar_stream()
            self.registrar_mensagem("Stream reiniciado com as novas configura√ß√µes")
            return True

    def iniciar_traducao(self):
        """Inicia o processo completo de tradu√ß√£o"""
        if self.em_execucao:
            return
            
        with self.trava_legenda:
            try:
                self.registrar_mensagem("üöÄ Iniciando processo de tradu√ß√£o...")
                
                # PASSO 1: Criar e verificar arquivo tempor√°rio ANTES de tudo
                self.registrar_mensagem("üìù Inicializando arquivo de legendas...")
                if not self.inicializar_arquivo_temp():
                    raise Exception("Falha cr√≠tica na cria√ß√£o do arquivo tempor√°rio")
                
                # PASSO 2: Aguardar e verificar m√∫ltiplas vezes
                for verificacao in range(5):
                    time.sleep(0.5)
                    
                    if not os.path.exists(self.caminho_legenda_temp):
                        self.registrar_mensagem(f"‚ö†Ô∏è Verifica√ß√£o {verificacao + 1}: Arquivo n√£o existe - recriando...")
                        if not self.inicializar_arquivo_temp():
                            raise Exception("Falha na verifica√ß√£o de exist√™ncia")
                        continue
                    
                    # Teste de leitura
                    try:
                        with open(self.caminho_legenda_temp, "r", encoding="utf-8") as f:
                            conteudo_teste = f.read()
                            if not conteudo_teste:
                                raise Exception("Arquivo vazio")
                        self.registrar_mensagem(f"‚úÖ Verifica√ß√£o {verificacao + 1}: OK - '{conteudo_teste[:50]}...'")
                        break
                    except Exception as e:
                        self.registrar_mensagem(f"‚ö†Ô∏è Verifica√ß√£o {verificacao + 1}: Erro de leitura - {e}")
                        if verificacao == 4:  # √öltima tentativa
                            raise Exception("Arquivo n√£o passou na verifica√ß√£o final")
                        if not self.inicializar_arquivo_temp():
                            raise Exception("Falha na recrea√ß√£o do arquivo")
                
                # PASSO 3: Verificar backups
                principal_ok, backups_ok = self.verificar_arquivo_principal_e_backups()
                self.registrar_mensagem(f"üìä Status pr√©-inicializa√ß√£o: Principal={'‚úÖ' if principal_ok else '‚ùå'} | Backups={len(backups_ok)}/{len(self.arquivos_backup)}")
                
                if not principal_ok:
                    raise Exception("Arquivo principal n√£o passou na verifica√ß√£o final")
                
                # PASSO 4: Carregar modelo Whisper
                self.registrar_mensagem(f"ü§ñ Carregando modelo {self.tamanho_modelo}...")
                self.modelo = WhisperModel(self.tamanho_modelo, device="cuda", compute_type="float16")
                
                # PASSO 5: Iniciar captura de √°udio
                self.registrar_mensagem("üé§ Iniciando captura de √°udio...")
                self.processo_audio = self.iniciar_captura_audio()
                
                # PASSO 6: Aguardar e verificar arquivo novamente antes do FFmpeg
                time.sleep(1.0)
                
                if not os.path.exists(self.caminho_legenda_temp):
                    raise Exception("Arquivo tempor√°rio foi removido inesperadamente antes do FFmpeg")
                
                # Teste final antes do FFmpeg
                try:
                    with open(self.caminho_legenda_temp, "r", encoding="utf-8") as f:
                        conteudo_final = f.read()
                        if not conteudo_final:
                            raise Exception("Arquivo vazio antes do FFmpeg")
                    self.registrar_mensagem(f"‚úÖ Verifica√ß√£o final antes FFmpeg: '{conteudo_final[:50]}...'")
                except Exception as e:
                    raise Exception(f"Teste final antes FFmpeg falhou: {e}")
                
                # PASSO 7: Iniciar stream do FFmpeg (aqui que est√° dando erro)
                self.registrar_mensagem("üì∫ Iniciando stream FFmpeg...")
                self.registrar_mensagem(f"üìÅ Arquivo que ser√° usado: {self.caminho_legenda_temp}")
                self.registrar_mensagem(f"üìè Tamanho do arquivo: {os.path.getsize(self.caminho_legenda_temp)} bytes")
                
                self.processo_stream = self.iniciar_stream()
                
                # PASSO 8: Verificar se o processo FFmpeg iniciou corretamente
                time.sleep(2.0)  # Dar tempo para o FFmpeg iniciar
                
                if self.processo_stream.poll() is not None:
                    # Processo j√° terminou, algo deu errado
                    raise Exception("Processo FFmpeg terminou imediatamente ap√≥s iniciar")
                
                # PASSO 9: Configurar ambiente
                os.environ["FONTCONFIG_PATH"] = "C:/Desenvolvimento/LEGENDA/fonts" if os.name == 'nt' else "/usr/share/fonts"
                
                # PASSO 10: Marcar como em execu√ß√£o e iniciar threads
                self.em_execucao = True
                
                # Thread 1: Processamento de √°udio/tradu√ß√£o
                self.thread_processamento = Thread(target=self.executar_loop_assincrono, daemon=True)
                self.thread_processamento.start()
                
                # Thread 2: Monitoramento geral (a cada 5 segundos)
                self.thread_monitoramento = Thread(target=self.monitorar_arquivo_temp, daemon=True)
                self.thread_monitoramento.start()
                
                # Thread 3: GUARDI√ÉO do arquivo (a cada 1 segundo) - NOVA!
                self.thread_guardian = Thread(target=self.guardian_do_arquivo, daemon=True)
                self.thread_guardian.start()
                
                efeito_total = self.atraso_video + self.atraso_legenda
                self.registrar_mensagem("üéâ Tradu√ß√£o iniciada com sucesso!")
                self.registrar_mensagem(f"üìπ V√≠deo: {self.atraso_video}s atrasado")
                self.registrar_mensagem(f"üìù Legendas: {abs(efeito_total)}s {'adiantadas' if efeito_total < 0 else 'atrasadas'} em rela√ß√£o ao v√≠deo")
                self.registrar_mensagem(f"üîÑ Arquivo FIXO (n√£o tempor√°rio): {self.caminho_legenda_temp}")
                self.registrar_mensagem(f"üõ°Ô∏è Monitor ULTRA-AGRESSIVO ativo (5s)")
                self.registrar_mensagem(f"üëÆ GUARDI√ÉO ativo (1s)")
                
                # Verifica√ß√£o final p√≥s-inicializa√ß√£o
                time.sleep(3)
                if not os.path.exists(self.caminho_legenda_temp):
                    self.registrar_mensagem("üö® ATEN√á√ÉO: Arquivo foi removido ap√≥s inicializa√ß√£o!")
                else:
                    self.registrar_mensagem("‚úÖ Verifica√ß√£o p√≥s-inicializa√ß√£o: arquivo ainda existe")
                    self.registrar_mensagem("üöÄ SISTEMA TRIPLO DE PROTE√á√ÉO ATIVO!")
                
            except Exception as e:
                self.em_execucao = False
                self.registrar_mensagem(f"üí• Erro ao iniciar a tradu√ß√£o: {e}")
                # Limpar processos se houve erro
                if hasattr(self, 'processo_audio') and self.processo_audio:
                    self.processo_audio.terminate()
                if hasattr(self, 'processo_stream') and self.processo_stream:
                    self.processo_stream.terminate()

    def parar_traducao(self):
        """Para todos os processos de tradu√ß√£o de forma segura"""
        with self.trava_legenda:
            self.em_execucao = False
            
            if self.processo_audio:
                try:
                    self.processo_audio.terminate()
                    self.processo_audio.wait(timeout=5)
                except:
                    self.processo_audio.kill()
                    
            if self.processo_stream:
                try:
                    self.processo_stream.terminate()
                    self.processo_stream.wait(timeout=5)
                except:
                    self.processo_stream.kill()

            # Limpar SISTEMA ARQUIVO PERMANENTE
            arquivos_principais = [
                self.caminho_legenda_ffmpeg,
                self.caminho_legenda_write
            ]
            
            for arquivo in arquivos_principais:
                try:
                    if os.path.exists(arquivo):
                        os.unlink(arquivo)
                        self.registrar_mensagem(f"üìÑ Arquivo permanente removido: {os.path.basename(arquivo)}")
                except Exception as e:
                    self.registrar_mensagem(f"‚ö†Ô∏è Erro ao remover arquivo permanente {os.path.basename(arquivo)}: {e}")
            
            # Limpar arquivos tempor√°rios do sistema (que n√£o deveriam existir, mas por seguran√ßa)
            arquivos_temp_extras = [
                f"{self.caminho_legenda_ffmpeg}.sync",
                f"{self.caminho_legenda_ffmpeg}.tmp", 
                f"{self.caminho_legenda_ffmpeg}.atomic",
                f"{self.caminho_legenda_ffmpeg}.emergency",
                f"{self.caminho_legenda_write}.tmp",
                f"{self.caminho_legenda_write}.atomic"
            ]
            
            for arquivo_temp in arquivos_temp_extras:
                try:
                    if os.path.exists(arquivo_temp):
                        os.unlink(arquivo_temp)
                        self.registrar_mensagem(f"üìÑ Arquivo temp extra removido: {os.path.basename(arquivo_temp)}")
                except Exception as e:
                    self.registrar_mensagem(f"‚ö†Ô∏è Erro ao remover temp {os.path.basename(arquivo_temp)}: {e}")

            # Limpar TODOS os arquivos de backup
            backups_removidos = 0
            for i, arquivo_backup in enumerate(self.arquivos_backup):
                try:
                    if os.path.exists(arquivo_backup):
                        os.unlink(arquivo_backup)
                        backups_removidos += 1
                except Exception as e:
                    self.registrar_mensagem(f"‚ö†Ô∏è Erro ao remover backup {i}: {e}")
            
            if backups_removidos > 0:
                self.registrar_mensagem(f"üßπ {backups_removidos} arquivos de backup removidos")
                    
            self.registrar_mensagem("‚úÖ Processo de tradu√ß√£o interrompido com seguran√ßa.")
            self.registrar_mensagem("üìä Estat√≠sticas finais:")
            self.registrar_mensagem(f"   - Total de updates: {self.contador_updates}")
            self.registrar_mensagem(f"   - Falhas consecutivas: {self.falhas_consecutivas}")
            self.registrar_mensagem("üóëÔ∏è Sistema arquivo permanente limpo completamente.")
        
def principal():
    """Fun√ß√£o principal do programa com SISTEMA ARQUIVO PERMANENTE"""
    try:
        import vlc
    except ImportError:
        print("Erro: A biblioteca python-vlc n√£o est√° instalada. Por favor, instale-a primeiro.")
        return
    
    print("üöÄ Iniciando Tradutor de Legendas com ARQUIVO PERMANENTE ANTI-CREATEFILEMAPPING...")
    print("üìã Verificando sistema...")
    
    tradutor = TradutorLegendas()
    
    # Verificar se ambos os arquivos foram criados
    ffmpeg_existe = os.path.exists(tradutor.caminho_legenda_ffmpeg)
    buffer_existe = os.path.exists(tradutor.caminho_legenda_write)
    
    if not ffmpeg_existe or not buffer_existe:
        print("‚ùå ERRO: Sistema arquivo permanente n√£o foi criado completamente")
        print(f"   üìñ Arquivo FFmpeg: {'‚úÖ' if ffmpeg_existe else '‚ùå'}")
        print(f"   ‚úèÔ∏è Buffer escrita: {'‚úÖ' if buffer_existe else '‚ùå'}")
        return
    
    # Mostrar informa√ß√µes detalhadas do sistema arquivo permanente
    tamanho_ffmpeg = os.path.getsize(tradutor.caminho_legenda_ffmpeg)
    tamanho_buffer = os.path.getsize(tradutor.caminho_legenda_write)
    
    print(f"‚úÖ SISTEMA ARQUIVO PERMANENTE criado com sucesso!")
    print(f"üìñ FFmpeg l√™ (PERMANENTE): {tradutor.caminho_legenda_ffmpeg} ({tamanho_ffmpeg} bytes)")
    print(f"‚úèÔ∏è Escrevemos (PERMANENTE): {tradutor.caminho_legenda_write} ({tamanho_buffer} bytes)")
    print(f"üõ°Ô∏è Sistema de {len(tradutor.arquivos_backup)} backups ativo")
    print(f"üîí ARQUIVOS NUNCA S√ÉO DELETADOS - apenas conte√∫do modificado")
    
    # Verificar quantos backups foram criados
    principal_ok, backups_ok = tradutor.verificar_arquivo_principal_e_backups()
    print(f"üìä Status inicial: FFmpeg={'‚úÖ' if principal_ok else '‚ùå'} | Backups={len(backups_ok)}/{len(tradutor.arquivos_backup)}")
    
    # Teste de leitura dos arquivos
    try:
        with open(tradutor.caminho_legenda_ffmpeg, "r", encoding="utf-8") as f:
            conteudo_ffmpeg = f.read()
        with open(tradutor.caminho_legenda_write, "r", encoding="utf-8") as f:
            conteudo_buffer = f.read()
        print(f"üìù Conte√∫do FFmpeg: '{conteudo_ffmpeg[:30]}...'")
        print(f"üìù Conte√∫do Buffer: '{conteudo_buffer[:30]}...'")
    except Exception as e:
        print(f"‚ùå ERRO ao ler arquivos iniciais: {e}")
        return
    
    tradutor.definir_atrasos(atraso_video_segundos=3.0, atraso_legenda_segundos=-5.0)
    
    print("üé¨ Iniciando tradu√ß√£o (com delay de 5s antes do FFmpeg)...")
    tradutor.iniciar_traducao()
    
    try:
        print("\n" + "="*100)
        print("üéÆ CONTROLES DISPON√çVEIS:")
        print("- Ctrl+C: Parar tradu√ß√£o")
        print("- Legendas exibidas no stream RTMP")
        print("- Para alterar atrasos, modifique os valores no c√≥digo e reinicie")
        print("")
        print("üõ°Ô∏è SISTEMA ARQUIVO PERMANENTE ANTI-CREATEFILEMAPPING:")
        print("- üìñ ARQUIVO FFMPEG: Dedicado exclusivamente para leitura (NUNCA deletado)")
        print("- ‚úèÔ∏è BUFFER ESCRITA: Dedicado para escrita das legendas (NUNCA deletado)")
        print("- üîÑ SINCRONIZA√á√ÉO: Apenas CONTE√öDO √© atualizado (a cada 500ms)")
        print("- üëÆ GUARDI√ÉO ULTRA-AGRESSIVO: verifica√ß√£o a cada 0.5 segundos")
        print("- üìä MONITOR: heartbeat a cada 30 segundos")
        print("- üîß MANUTEN√á√ÉO: preventiva a cada 5 minutos")
        print(f"- üóÇÔ∏è {len(tradutor.arquivos_backup)} arquivos de backup autom√°ticos")
        print("- üìÅ CAMINHOS ABSOLUTOS: melhor compatibilidade FFmpeg")
        print("- ‚ö° RECUPERA√á√ÉO INSTANT√ÇNEA: recria arquivos em 0.5s")
        print("- üÜò SISTEMA √öLTIMO RECURSO: para falhas cr√≠ticas")
        print("- üõ°Ô∏è ANTI-CREATEFILEMAPPING: elimina 100% dos conflitos de acesso")
        print("- üîê OPERA√á√ïES SEEK: modifica√ß√£o de conte√∫do sem deletar arquivo")
        print("- üîç VERIFICA√á√ÉO RIGOROSA: 10 verifica√ß√µes antes de iniciar FFmpeg")
        print("- ‚è≥ DELAY CR√çTICO: 5 segundos antes de iniciar FFmpeg")
        print("- üîÑ REINICIALIZA√á√ÉO AUTOM√ÅTICA: FFmpeg reinicia se arquivo for recriado")
        print("="*100)
        
        contador = 0
        ultimo_status = time.time()
        
        while True:
            time.sleep(1)
            contador += 1
            
            # Status super detalhado a cada 2 minutos
            if contador % 120 == 0:
                agora = time.time()
                principal_ok, backups_ok = tradutor.verificar_arquivo_principal_e_backups()
                
                try:
                    # Status de ambos os arquivos permanentes
                    ffmpeg_existe = os.path.exists(tradutor.caminho_legenda_ffmpeg)
                    buffer_existe = os.path.exists(tradutor.caminho_legenda_write)
                    
                    tamanho_ffmpeg = os.path.getsize(tradutor.caminho_legenda_ffmpeg) if ffmpeg_existe else 0
                    tamanho_buffer = os.path.getsize(tradutor.caminho_legenda_write) if buffer_existe else 0
                    
                    uptime_min = contador // 60
                    print(f"üîç STATUS [{uptime_min}min]: FFmpeg={'‚úÖ' if ffmpeg_existe else '‚ùå'}({tamanho_ffmpeg}b) | Buffer={'‚úÖ' if buffer_existe else '‚ùå'}({tamanho_buffer}b)")
                    print(f"   üõ°Ô∏è Backups: {len(backups_ok)}/{len(tradutor.arquivos_backup)} | üìä Updates: {tradutor.contador_updates} | Falhas: {tradutor.falhas_consecutivas}")
                    
                    if ffmpeg_existe:
                        with open(tradutor.caminho_legenda_ffmpeg, "r", encoding="utf-8") as f:
                            amostra_ffmpeg = f.read()[:25]
                        print(f"   üìñ FFmpeg (PERMANENTE): '{amostra_ffmpeg}...'")
                    
                    if buffer_existe:
                        with open(tradutor.caminho_legenda_write, "r", encoding="utf-8") as f:
                            amostra_buffer = f.read()[:25]
                        print(f"   ‚úèÔ∏è Buffer (PERMANENTE): '{amostra_buffer}...'")
                        
                except Exception as e:
                    print(f"üîç STATUS [{contador//60}min]: ‚ö†Ô∏è Erro ao ler status detalhado: {e}")
                    
    except KeyboardInterrupt:
        print("\nüõë Parando tradu√ß√£o...")
        tradutor.parar_traducao()
        print("‚úÖ Tradu√ß√£o finalizada com seguran√ßa")
        print("üßπ Sistema arquivo permanente limpo completamente")

if __name__ == "__main__":
    principal()